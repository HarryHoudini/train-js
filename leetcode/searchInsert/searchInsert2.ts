// Необходимо найти индекс, по которому должно быть вставлено значение target в отсортированный массив nums, если оно не найдено.
// Решение использует алгоритм бинарного поиска для эффективного нахождения этого индекса.

function searchInsert(nums, target) {
    let res = -1; // Переменная для хранения результата
    let arrLength = nums.length; // Длина массива
    let lo = 0; // Нижняя граница поиска
    let hi = arrLength - 1; // Верхняя граница поиска

    while (lo <= hi) { // Пока нижняя граница не превысила верхнюю
        let mi = Math.floor(lo + (hi - lo) / 2); // Середина текущего интервала

        if (nums[mi] === target) {
            return mi; // Если нашли target, возвращаем индекс
        }

        if (nums[mi] > target) {
            res = mi; // Если середина больше target, обновляем res и сдвигаем верхнюю границу
            hi = mi - 1;
        }

        if (nums[mi] < target) {
            lo = mi + 1; // Если середина меньше target, сдвигаем нижнюю границу
        }
    }

    if (res === -1) return arrLength; // Если res не обновился, возвращаем длину массива
    return res; // Возвращаем индекс для вставки
}

// Объяснение решения
// Инициализация переменных:

// res изначально равен -1, это переменная для хранения результата.
// arrLength содержит длину массива.
// lo и hi устанавливают нижнюю и верхнюю границы поиска.
// Цикл бинарного поиска:

// Пока нижняя граница lo не превышает верхнюю hi, продолжаем поиск.
// mi вычисляется как середина текущего интервала.
// Проверка значения в середине:

// Если элемент в середине равен target, возвращаем индекс mi.
// Если элемент в середине больше target, обновляем res на mi и сдвигаем верхнюю границу hi.
// Если элемент в середине меньше target, сдвигаем нижнюю границу lo.
// Возврат результата:

// Если res остался равен -1, значит target больше всех элементов массива, возвращаем длину массива.
// В противном случае, возвращаем res, который содержит индекс для вставки.
